Để học cách viết code đẹp, dễ đọc, và hiệu quả, có nhiều kênh YouTube tuyệt vời với nội dung chất lượng. Dưới đây là một số kênh nổi bật mà bạn có thể tham khảo:

### **1. [Traversy Media](https://www.youtube.com/c/TraversyMedia)**
- **Nội dung:** Đa dạng về lập trình web (HTML, CSS, JavaScript, PHP, Node.js, React, etc.) và các nguyên tắc tốt trong lập trình.
- **Điểm mạnh:** Trình bày đơn giản, dễ hiểu, phù hợp cho cả người mới bắt đầu và những người có kinh nghiệm. Các video tập trung vào cả việc làm các dự án thực tế và viết code sạch.

### **2. [The Net Ninja](https://www.youtube.com/c/TheNetNinja)**
- **Nội dung:** Lập trình web (HTML, CSS, JavaScript, Vue.js, React, Node.js, Python, etc.), đặc biệt là JavaScript và các framework hiện đại.
- **Điểm mạnh:** Các khóa học miễn phí được chia thành từng loạt video, hướng dẫn kỹ lưỡng, chú trọng vào việc viết code rõ ràng và dễ bảo trì.

### **3. [Tech With Tim](https://www.youtube.com/c/TechWithTim)**
- **Nội dung:** Python, AI, Machine Learning, và lập trình game với Pygame.
- **Điểm mạnh:** Các dự án thực tế kèm theo giải thích chi tiết về cách viết code đẹp và tối ưu. Tim cũng có các video về Python cơ bản, cách tổ chức code, và quản lý dự án.

### **4. [Corey Schafer](https://www.youtube.com/c/Coreyms)**
- **Nội dung:** Python, Git, lập trình hướng đối tượng (OOP), và các công nghệ liên quan như Flask, Django, và REST APIs.
- **Điểm mạnh:** Corey có phong cách giảng dạy rất rõ ràng, dễ hiểu, và chú trọng vào việc viết code sạch, tuân thủ các tiêu chuẩn tốt trong lập trình.

### **5. [Clean Code](https://www.youtube.com/c/CleanCode)**
- **Nội dung:** Tập trung vào các nguyên tắc và phương pháp của **Clean Code**, dựa trên cuốn sách nổi tiếng của Robert C. Martin.
- **Điểm mạnh:** Các bài giảng giúp bạn học cách tổ chức mã nguồn, giảm thiểu sự phức tạp, và tuân thủ các tiêu chuẩn coding như SOLID, DRY, và KISS.

### **6. [Programming with Mosh](https://www.youtube.com/c/programmingwithmosh)**
- **Nội dung:** Lập trình web, JavaScript, Python, và các khóa học về nguyên tắc lập trình cơ bản.
- **Điểm mạnh:** Mosh tập trung vào giải thích rõ ràng các khái niệm, và cách viết code chuyên nghiệp. Các khóa học của anh giúp người học hiểu được tầm quan trọng của code sạch và cách viết code dễ duy trì.

### **7. [Academind](https://www.youtube.com/c/Academind)**
- **Nội dung:** Chủ yếu về JavaScript, TypeScript, và các công nghệ như React, Angular, và Node.js.
- **Điểm mạnh:** Kênh hướng dẫn cách tiếp cận viết code hiệu quả, dễ mở rộng, và đặc biệt tập trung vào các dự án thực tế.

### **8. [Fireship](https://www.youtube.com/c/Fireship)**
- **Nội dung:** Các video ngắn gọn nhưng súc tích về nhiều công nghệ lập trình, đặc biệt là JavaScript, web development, cloud, và DevOps.
- **Điểm mạnh:** Fireship có các video chất lượng cao về các nguyên tắc viết code hiện đại và tối ưu hóa ứng dụng. Họ cũng giới thiệu về các xu hướng công nghệ mới một cách ngắn gọn, dễ hiểu.

---

### **Tại sao nên học cách viết code đẹp?**
Viết code đẹp, rõ ràng, và dễ bảo trì không chỉ giúp bạn tạo ra phần mềm tốt hơn mà còn giúp bạn và người khác dễ dàng làm việc với mã nguồn về sau. Điều này rất quan trọng khi làm việc trong nhóm hoặc trên các dự án lớn.

Nếu bạn muốn tập trung vào việc học cách viết code đẹp, hãy kết hợp việc xem các video hướng dẫn với việc tự luyện tập và đọc sách như **Clean Code** của Robert C. Martin.

Chúc bạn học tốt!

===================

Để viết code dễ bảo trì và mở rộng, bạn nên tuân theo các kinh nghiệm và nguyên tắc sau:

1. **Viết code sạch (Clean Code):**
   - **Tên biến, hàm, lớp có ý nghĩa:** Đặt tên rõ ràng, dễ hiểu giúp người khác (và chính bạn) dễ dàng hiểu chức năng.
   - **Tránh lặp lại code (DRY - Don't Repeat Yourself):** Tái sử dụng code thông qua hàm, lớp hoặc module.
   - **Đơn giản hóa logic:** Tránh viết code phức tạp khi có thể giải quyết bằng cách đơn giản hơn.

2. **Tuân thủ coding style nhất quán:**
   - **Sử dụng quy tắc định dạng chung:** Theo chuẩn của ngôn ngữ hoặc dự án (ví dụ: PEP 8 cho Python).
   - **Dùng công cụ linting và formatting:** Như ESLint cho JavaScript hoặc Prettier để tự động hóa việc định dạng.

3. **Áp dụng nguyên tắc SOLID và thiết kế hướng đối tượng:**
   - **Single Responsibility Principle:** Mỗi lớp hay hàm chỉ nên có một trách nhiệm duy nhất.
   - **Open/Closed Principle:** Code nên mở rộng được mà không cần sửa đổi code hiện có.
   - **Liskov Substitution Principle, Interface Segregation Principle, Dependency Inversion Principle:** Áp dụng khi thiết kế hệ thống lớn.

4. **Viết comment và tài liệu rõ ràng:**
   - **Comment khi cần thiết:** Giải thích các đoạn code phức tạp hoặc lý do cho một quyết định thiết kế.
   - **Tài liệu hóa API và module:** Sử dụng docstring hoặc các công cụ tạo tài liệu tự động.

5. **Viết code dễ kiểm thử:**
   - **Tách biệt logic:** Giúp viết unit test dễ dàng hơn.
   - **Sử dụng Test-Driven Development (TDD):** Viết test trước khi viết code thực thi.
   - **Đảm bảo độ bao phủ của test cao:** Phát hiện lỗi sớm và giảm thiểu bug.

6. **Sử dụng hệ thống quản lý phiên bản hiệu quả:**
   - **Commit thường xuyên với thông điệp rõ ràng:** Giúp theo dõi thay đổi dễ dàng.
   - **Sử dụng branching strategy hợp lý:** Như GitFlow hoặc Trunk-based Development.
   - **Code review:** Kiểm tra code của nhau để cải thiện chất lượng.

7. **Thiết kế kiến trúc module hóa:**
   - **Phân chia code thành các module hoặc layer:** Dễ dàng quản lý và mở rộng.
   - **Sử dụng interface và abstraction:** Giảm sự phụ thuộc giữa các thành phần.

8. **Quản lý phụ thuộc và thư viện bên ngoài:**
   - **Sử dụng công cụ quản lý phụ thuộc:** Như npm cho JavaScript hoặc Maven cho Java.
   - **Cập nhật phiên bản định kỳ:** Đảm bảo sử dụng phiên bản ổn định và bảo mật.

9. **Tối ưu hóa hiệu suất và tài nguyên:**
   - **Chỉ tối ưu khi cần thiết:** Tránh tối ưu hóa sớm gây phức tạp code.
   - **Sử dụng công cụ profiling:** Để xác định điểm nghẽn hiệu suất thực sự.

10. **Liên tục học hỏi và cập nhật kiến thức:**
    - **Theo dõi xu hướng công nghệ mới:** Giúp áp dụng những phương pháp và công cụ tốt hơn.
    - **Tham gia cộng đồng:** Học hỏi kinh nghiệm từ các developer khác.

Áp dụng những kinh nghiệm trên sẽ giúp code của bạn trở nên dễ bảo trì, dễ mở rộng và nâng cao chất lượng tổng thể của dự án.


---------
"hard-coded" (e.g., fixed inputs that should be parameterized or configurable)
![[Pasted image 20241012093327.png]]

Ussualy:
- **JavaScript:**
    - Function Names: `camelCase`
    - File Names: `kebab-case`
- **Python:**
    - Function Names: `snake_case`
    - File Names: `snake_case`

## `config.py` and `.env`: 
#### **Key Differences**

1. **Sensitivity:**
    
    - **Config Files:** Store non-sensitive settings; safe to commit to version control.
    - **`.env` Files:** Store sensitive information; should **not** be committed to version control.
2. **Format and Complexity:**
    
    - **Config Files:** Support complex data types and nested structures.
    - **`.env` Files:** Simple flat key-value pairs.
3. **Access Method:**
    
    - **Config Files:** Parsed using appropriate parsers (`configparser`, `json`, `yaml`).
    - **`.env` Files:** Loaded into environment variables and accessed via `os.environ`.
4. **Purpose in Development Workflow:**
    
    - **Config Files:** Define default or shared configurations across environments.
    - **`.env` Files:** Customize or override configurations per environment (development, testing, production).
    ==========================================================
- **Config Files:**
    
    - Used for general, non-sensitive application settings.
    - Can have complex structures.
    - Usually committed to version control.
- **`.env` Files:**
    
    - Used for sensitive data and environment-specific settings.
    - Simple key-value pairs.
    - Should not be committed to version control.
- **Separation of Concerns:** Keeps your codebase clean and secure by separating sensitive data from the application logic.
- **Flexibility:** Allows different settings per environment without changing code.
- **Security:** Reduces the risk of accidentally exposing sensitive information.


### Cách import tuyệt đối và tương đối 
### Tổng kết về Import Tương Đối và Tuyệt Đối trong Python

#### 1. **Import Tuyệt Đối**:
   - **Khi sử dụng**: Import từ bất kỳ vị trí nào trong project, dựa trên cấu trúc thư mục từ gốc của dự án.
   - **Ưu điểm**: Rõ ràng, dễ bảo trì, và hoạt động tốt khi chạy file trực tiếp hoặc từ bất kỳ thư mục nào.
   - **Ví dụ**:
     ```python
     from backend_package.ChatAssistant_class import ChatAssistant
     ```

#### 2. **Import Tương Đối**:
   - **Khi sử dụng**: Dùng khi bạn làm việc bên trong một package và không chạy trực tiếp file đó mà thông qua một entry point khác (như `main.py`).
   - **Ưu điểm**: Giữ cho code gọn gàng, tránh phải hardcode đường dẫn nếu các module nằm cùng package.
   - **Nhược điểm**: Không hoạt động khi bạn chạy module trực tiếp.
   - **Ví dụ**:
     ```python
     from .ChatAssistant_class import ChatAssistant
     ```

### Khi nào sử dụng Import Tương Đối?
- Khi các file nằm trong cùng package và bạn không chạy file đó trực tiếp từ dòng lệnh mà thông qua một entry point khác (như `main.py`).
- Import tương đối dùng để tránh phải chỉ rõ đường dẫn tuyệt đối của module trong dự án, nhất là khi bạn làm việc với nhiều module có sự liên quan chặt chẽ trong cùng một thư mục.

### Khi nào không nên sử dụng Import Tương Đối?
- Khi bạn muốn chạy trực tiếp một file từ dòng lệnh. Lúc này, Python không nhận diện được cấu trúc package, dẫn đến lỗi.
- Trong những trường hợp này, bạn nên dùng import tuyệt đối để rõ ràng về đường dẫn của module.

### Ví dụ Cụ Thể

#### Cấu trúc dự án:
```
APIBasicRAG_chatbot/
├── backend_package/
│   ├── ChatAssistant_class.py
│   └── Threading_ExtendedChatAssistant_class_useCheckTenantAccessToken.py
├── main.py
├── .env
└── config.py
```

#### 1. **Import Tương Đối**:
   - Trong file `Threading_ExtendedChatAssistant_class_useCheckTenantAccessToken.py`:
     ```python
     from .ChatAssistant_class import ChatAssistant
     ```
   - **Cách chạy đúng**:
     ```bash
     python main.py
     ```

#### 2. **Import Tuyệt Đối**:
   - Trong file `Threading_ExtendedChatAssistant_class_useCheckTenantAccessToken.py`:
     ```python
     from backend_package.ChatAssistant_class import ChatAssistant
     ```
   - **Cách chạy đúng** (khi chạy trực tiếp file):
     ```bash
     python backend_package/Threading_ExtendedChatAssistant_class_useCheckTenantAccessToken.py
     ```

### Tổng Kết
- Sử dụng **import tương đối** khi các module nằm trong cùng package và bạn không chạy module trực tiếp từ dòng lệnh.
- Sử dụng **import tuyệt đối** khi bạn chạy module trực tiếp hoặc cần rõ ràng về đường dẫn module trong dự án.

**Có**, import tuyệt đối **hoàn toàn chạy được** khi bạn sử dụng `main.py` làm entry point để khởi chạy ứng dụng. Thực tế, import tuyệt đối là cách phổ biến và thường được khuyến khích sử dụng trong các dự án Python lớn để đảm bảo rõ ràng và dễ bảo trì.


Cách bạn sử dụng import tương đối như `from get_tenantAccessToken_funct import get_tenant_access_token` trong code của bạn sẽ **không hoạt động** đúng cả khi bạn **chạy file trực tiếp** và khi **gọi qua `main.py`**, bởi vì:

1. **Khi chạy file trực tiếp** (`python backend_package/your_file.py`):
    
    - Python sẽ coi file đó là một **script độc lập**, không phải là một phần của package `backend_package`. Vì thế, nó sẽ không thể tìm thấy module `get_tenantAccessToken_funct` nằm trong cùng thư mục.
    - Để làm cho import hoạt động trong trường hợp này, bạn cần sử dụng **import tuyệt đối** với đường dẫn đầy đủ từ thư mục gốc dự án.
2. **Khi gọi qua `main.py`** (`python main.py`):
    
    - Khi `main.py` gọi file của bạn, Python coi file đó là một module của package `backend_package`. Nếu `main.py` nằm ở thư mục gốc và gọi các module bên trong `backend_package`, thì bạn có thể sử dụng import tương đối (nhưng phải dùng cú pháp `.`).

### Cách để import hoạt động trong cả hai trường hợp:

Bạn có hai tùy chọn:

### 1. **Sử dụng import tuyệt đối (nên dùng)**:

- Thay `from get_tenantAccessToken_funct import get_tenant_access_token` bằng:
    
    python
    
    Copy code
    
    `from backend_package.get_tenantAccessToken_funct import get_tenant_access_token`
    
- **Lợi ích**: Import tuyệt đối sẽ hoạt động cả khi bạn chạy file trực tiếp và khi gọi từ `main.py`, vì Python sẽ biết chính xác nơi tìm module trong dự án.

### 2. **Sử dụng import tương đối với dấu chấm khi gọi từ `main.py`**:

- Nếu bạn muốn sử dụng import tương đối, bạn phải sử dụng dấu chấm để chỉ ra rằng `get_tenantAccessToken_funct` nằm trong cùng package với file hiện tại. Điều này chỉ hoạt động khi bạn chạy thông qua `main.py` (bạn không thể chạy file trực tiếp):
    
    python
    
    Copy code
    
    `from .get_tenantAccessToken_funct import get_tenant_access_token`
    
- **Lưu ý**: Điều này **sẽ không hoạt động** nếu bạn chạy trực tiếp file Python trong `backend_package` mà không thông qua `main.py`.

### Tóm lại:

- **Nếu bạn muốn import hoạt động cả khi chạy trực tiếp và khi gọi từ `main.py`**, hãy sử dụng **import tuyệt đối**:
    
    python
    
    Copy code
    
    `from backend_package.get_tenantAccessToken_funct import get_tenant_access_token`
    
- **Nếu bạn chỉ chạy qua `main.py`** và muốn giữ import tương đối, hãy sử dụng dấu chấm:
    
    python
    
    Copy code
    
    `from .get_tenantAccessToken_funct import get_tenant_access_token`
    

### Kết luận:

- **Import tuyệt đối**: Hoạt động trong mọi trường hợp.
- **Import tương đối (với dấu chấm)**: Chỉ hoạt động khi gọi từ `main.py`, không khi chạy file trực tiếp.